{
  "hash": "192bdaa8bc959ada8285c5a5a3d0dfbf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home_Ex01\"\nauthor: \"Jenna Cheo\"\ndate: \"September 5, 2024\"\ndate-modified: \"September 22, 2024\"\nformat: html\neditor: visual\nexecute: \n  echo: true\n  eval: false\n  freeze: true\n---\n\n\n# 1.0 Introduction\n\nMillions of people have their lives shattered by armed conflict – wars – every year.\n\nArmed conflict has been on the rise since about 2012, after a decline in the 1990s and early 2000s. First came conflicts in Libya, Syria and Yemen, triggered by the 2011 Arab uprisings. Libya’s instability spilled south, helping set off a protracted crisis in the Sahel region. A fresh wave of major combat followed: the 2020 Azerbaijani-Armenian war over the Nagorno-Karabakh enclave, horrific fighting in Ethiopia’s northern Tigray region that began weeks later, the conflict prompted by the Myanmar army’s 2021 power grab and Russia’s 2022 assault on Ukraine. Add to those 2023’s devastation in Sudan and Gaza. Around the globe, more people are dying in fighting, being forced from their homes or in need of life-saving aid than in decades.\n\nSource: [10 Conflicts to Watch in 2024](https://www.crisisgroup.org/global/10-conflicts-watch-2024)\n\n# 2.0 Importing Packages\n\nBefore we start the exercise, we will need to import necessary R packages first. We will use the following packages:\n\n-   [`sf`](https://rdrr.io/github/r-spatial/sf/man/sf-package.html) : provides a standardised way to encode spatial vector data in R environment, facilitating spatial data operations and analysis.\n\n-   [`st`](https://rdrr.io/cran/sf/man/st.html) : creats simple features from numeric vectors, matrices, or lists, enabling the representation and manipulation of spatial structures in R.\n\n-   [`spatstat`](https://cran.r-project.org/web/packages/spatstat/): A package for statistical analysis of spatial data, specifically Spatial Point Pattern Analysis. This package was provided by Baddeley, Turner and Ruback (2015) and gives a comprehensive list of functions to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.\n\n-   [`tidyverse`](https://www.tidyverse.org/) : a collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structure.\n\n-   [`raster`](https://cran.r-project.org/web/packages/raster/) : reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.\n\n-   [`tmap`](https://cran.r-project.org/web/packages/tmap/): Packages used for creating static and interactive visualisations summary statistics and KDE layers.\n\n-   `lubridate`: splits the data into quarters by their years.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, st, tidyverse, raster, tmap, tmaptools, ggplot2, spatstat, lubridate, osmdata, OpenStreetMap, sparr)\n```\n:::\n\n\n# 3.0 Importing Dataset into R environment\n\n## 3.1 Datasets\n\n1.  For the purpose of this assignment, **armed conflict data** of Myanmar between January 2021 - June 2024 from [Armed Conflict Location & Event Data (ACLED)](https://acleddata.com/). In terms of event types, we are focusing on four main event types, namely: Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians.\n2.  We will also be using geospatial data on the Myanmar National Border in ESRI Shapefile format. [(Myanmar National Boundary MIMU v9.4)](http://geonode.themimu.info/layers/geonode%3Ammr_polbnda_adm0_250k_mimu_1)\n3.  Finally, we will be utilizing OpenStreetMap of Myanmar in shapefile format. [(](#0)[OSM](https://download.geofabrik.de/asia/myanmar.html)[)](#0)\n\n## 3.2 Importing the Datasets\n\n### 3.2.1 Myanmar Armed Conflict Dataset\n\nThe dataset, which we downloaded from ACLED, is in csv format. To use this data in an R-environment, we need to import it as an sf object. We can do this using the **`st_read()`** function of the **`sf`** package. This function reads the csv data and returns an **`sf`** object that can be used for further analysis.\n\nThe data has also been transformed such that the EPSG coordinates are accurate to Myanmar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf <- read_csv(\"data/2021-01-01-2024-06-30-Myanmar.csv\") %>%\n  st_as_sf(coords = c(\n    \"longitude\", \"latitude\"),\n    crs=4326) %>%\n  st_transform(crs = 32647) %>%\n  mutate(event_date = dmy(event_date))\n```\n:::\n\n\nThe `event_date` column is categorized by\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf <- acled_sf %>%\n  mutate(quarter = quarter(event_date))\n```\n:::\n\n\n### 3.2.2 Myanmar Administrative Boundary Data\n\nThe code chunk below uses [`st_read()`](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Myanmar shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_sf <- st_read(dsn = \"data/mmr_polbnda2_adm1_250k_mimu_1\", \n                 layer = \"mmr_polbnda2_adm1_250k_mimu_1\") %>%\n  st_as_sf(coords =c(\n    \"longitude\", \"latitude\"),\n           crs = 4326) %>%\n  st_transform(crs = 32647)\n```\n:::\n\n\n### 3.2.3 OpenStreetMap of Myanmar\n\nTo import the OpenStreetMap of Myanmar, I utilized `st_read()` once more.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nosm = st_read(\"data/myanmar-latest-free.shp\", layer=\"gis_osm_places_a_free_1\")\n```\n:::\n\n\n## 3.3 Mapping the geospatial data sets\n\nIt is also useful for us to plot a map to show spatial patters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\n```\n:::\n\n\nThe code chunk below plots the armed conflict data in Myanmar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf %>%\n  tm_shape()+tm_dots()\n```\n:::\n\n\n# 4.0 Geospatial Data Wrangling\n\n## 4.1 Separating the data by year and quarter\n\nThe code chunk below separates the data provided into year and quarter for easier plotting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# year 2021\nacled_2021.Q1_sf <- acled_sf %>%\n  filter(year == '2021') %>%\n  filter(quarter == '1')\n\nacled_2021.Q2_sf <- acled_sf %>%\n  filter(year == '2021') %>%\n  filter(quarter == '2')\n\nacled_2021.Q3_sf <- acled_sf %>%\n  filter(year == '2021') %>%\n  filter(quarter == '3')\n\nacled_2021.Q4_sf <- acled_sf %>%\n  filter(year == '2021') %>%\n  filter(quarter == '4')\n\n# year 2022\nacled_2022.Q1_sf <- acled_sf %>%\n  filter(year == '2022') %>%\n  filter(quarter == '1')\n\nacled_2022.Q2_sf <- acled_sf %>%\n  filter(year == '2022') %>%\n  filter(quarter == '2')\n\nacled_2022.Q3_sf <- acled_sf %>%\n  filter(year == '2022') %>%\n  filter(quarter == '3')\n\nacled_2022.Q4_sf <- acled_sf %>%\n  filter(year == '2022') %>%\n  filter(quarter == '4')\n\n\n# year 2023\nacled_2023.Q1_sf <- acled_sf %>%\n  filter(year == '2023') %>%\n  filter(quarter == '1')\n\nacled_2023.Q2_sf <- acled_sf %>%\n  filter(year == '2023') %>%\n  filter(quarter == '2')\n\nacled_2023.Q3_sf <- acled_sf %>%\n  filter(year == '2023') %>%\n  filter(quarter == '3')\n\nacled_2023.Q4_sf <- acled_sf %>%\n  filter(year == '2023') %>%\n  filter(quarter == '4')\n\n\n# year 2024\nacled_2024.Q1_sf <- acled_sf %>%\n  filter(year == '2024') %>%\n  filter(quarter == '1')\n\nacled_2024.Q2_sf <- acled_sf %>%\n  filter(year == '2024') %>%\n  filter(quarter == '2')\n```\n:::\n\n\n## 4.2 Converting sf data frames to sp’s Spatial\\* class\n\nThe code chunk below uses [*as_Spatial()*](https://r4gdsa.netlify.app/chap04.html?q=KDE%20layers) of **sf** package to convert the geospatial data from simple feature data frame to sp’s Spatial\\* class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacled <- as_Spatial(acled_sf)\n\n# by quarters\nacled_2021.Q1 <- as_Spatial(acled_2021.Q1_sf)\nacled_2021.Q2 <- as_Spatial(acled_2021.Q2_sf)\nacled_2021.Q3 <- as_Spatial(acled_2021.Q3_sf)\nacled_2021.Q4 <- as_Spatial(acled_2021.Q4_sf)\n\nacled_2022.Q1 <- as_Spatial(acled_2022.Q1_sf)\nacled_2022.Q2 <- as_Spatial(acled_2022.Q2_sf)\nacled_2022.Q3 <- as_Spatial(acled_2022.Q3_sf)\nacled_2022.Q4 <- as_Spatial(acled_2022.Q4_sf)\n\nacled_2023.Q1 <- as_Spatial(acled_2023.Q1_sf)\nacled_2023.Q2 <- as_Spatial(acled_2023.Q2_sf)\nacled_2023.Q3 <- as_Spatial(acled_2023.Q3_sf)\nacled_2023.Q4 <- as_Spatial(acled_2023.Q4_sf)\n\nacled_2024.Q1 <- as_Spatial(acled_2024.Q1_sf)\nacled_2024.Q2 <- as_Spatial(acled_2024.Q2_sf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_2021.Q1\n```\n:::\n\n\n## 4.3 Converting the simple features to **spatstat’s ppp (planar point pattern) object**\n\n**spatstat** requires the analytical data in ***ppp*** object form. Hence we will convert `sf` objects to `ppp` objects using [`as.ppp()`](https://rdrr.io/pkg/spatstat.geom/man/as.ppp.html) function by providing the point coordinates and the observation window.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacled_ppp <- as.ppp(st_coordinates(acled_sf), st_bbox(acled_sf))\n\n# by quarters\nacled_2021.Q1_ppp <- as.ppp(st_coordinates(acled_2021.Q1_sf), st_bbox(acled_2021.Q1_sf))\nacled_2021.Q2_ppp <- as.ppp(st_coordinates(acled_2021.Q2_sf), st_bbox(acled_2021.Q2_sf))\nacled_2021.Q3_ppp <- as.ppp(st_coordinates(acled_2021.Q3_sf), st_bbox(acled_2021.Q3_sf))\nacled_2021.Q4_ppp <- as.ppp(st_coordinates(acled_2021.Q4_sf), st_bbox(acled_2021.Q4_sf))\n\nacled_2022.Q1_ppp <- as.ppp(st_coordinates(acled_2022.Q1_sf), st_bbox(acled_2022.Q1_sf))\nacled_2022.Q2_ppp <- as.ppp(st_coordinates(acled_2022.Q2_sf), st_bbox(acled_2022.Q2_sf))\nacled_2022.Q3_ppp <- as.ppp(st_coordinates(acled_2022.Q3_sf), st_bbox(acled_2022.Q3_sf))\nacled_2022.Q4_ppp <- as.ppp(st_coordinates(acled_2022.Q4_sf), st_bbox(acled_2022.Q4_sf))\n\nacled_2023.Q1_ppp <- as.ppp(st_coordinates(acled_2023.Q1_sf), st_bbox(acled_2023.Q1_sf))\nacled_2023.Q2_ppp <- as.ppp(st_coordinates(acled_2023.Q2_sf), st_bbox(acled_2023.Q2_sf))\nacled_2023.Q3_ppp <- as.ppp(st_coordinates(acled_2023.Q3_sf), st_bbox(acled_2023.Q3_sf))\nacled_2023.Q4_ppp <- as.ppp(st_coordinates(acled_2023.Q4_sf), st_bbox(acled_2023.Q4_sf))\n\nacled_2024.Q1_ppp <- as.ppp(st_coordinates(acled_2024.Q1_sf), st_bbox(acled_2024.Q1_sf))\nacled_2024.Q2_ppp <- as.ppp(st_coordinates(acled_2024.Q2_sf), st_bbox(acled_2024.Q2_sf))\n\nplot(acled_2021.Q1_ppp)\n```\n:::\n\n\nNext, we will take a quick look at the summary statistics of the newly created ppp object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(acled_2021.Q1_ppp)\n```\n:::\n\n\n## 4.4 Handling duplicated points\n\nIt is previously mentioned in `summary(acled_ppp)` that there are duplicated points in the patterns. We can double confirm the duplication in a ***ppp*** object by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(acled_2021.Q1_ppp))\n```\n:::\n\n\nSince the above code chunk returns TRUE, we will use `sum()` and `multiplicity()` functions to see how many locations have more than one point event.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(multiplicity(acled_2021.Q1_ppp) > 1)\n```\n:::\n\n\nWe can address this by using `rjitter()` which will add a small perturbation to the duplicate points so that they do not occupy the exact same spaces.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacled_ppp_jit <- rjitter(acled_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\n# by quarters\nacled_2021.Q1_ppp_jit <- rjitter(acled_2021.Q1_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2021.Q2_ppp_jit <- rjitter(acled_2021.Q2_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2021.Q3_ppp_jit <- rjitter(acled_2021.Q3_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2021.Q4_ppp_jit <- rjitter(acled_2021.Q4_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\nacled_2022.Q1_ppp_jit <- rjitter(acled_2022.Q1_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2022.Q2_ppp_jit <- rjitter(acled_2022.Q2_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2022.Q3_ppp_jit <- rjitter(acled_2022.Q3_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2022.Q4_ppp_jit <- rjitter(acled_2022.Q4_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\nacled_2023.Q1_ppp_jit <- rjitter(acled_2023.Q1_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2023.Q2_ppp_jit <- rjitter(acled_2023.Q2_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2023.Q3_ppp_jit <- rjitter(acled_2023.Q3_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2023.Q4_ppp_jit <- rjitter(acled_2023.Q4_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\nacled_2024.Q1_ppp_jit <- rjitter(acled_2024.Q1_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2024.Q2_ppp_jit <- rjitter(acled_2024.Q2_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n```\n:::\n\n\nNext, we will check if there is still any duplicate points in our dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(acled_2021.Q1_ppp_jit))\n```\n:::\n\n\n## 4.5 Creating ***owin*** object\n\nSince we have imported the Myanmar boundary, we will now convert the `myanmar_sf` object into an `owin` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_owin <- as.owin(myanmar_sf)\nplot(myanmar_owin)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(myanmar_owin)\n```\n:::\n\n\n## 4.6 Creating point events objects in owin Object\n\nIn this last step of geospatial data wrangling, we will extract armed conflict events that are located within Myanmar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacledmyanmar_ppp = acled_ppp[myanmar_owin]\n\n# by quarters\nacledmyanmar_2021.Q1_ppp = acled_2021.Q1_ppp[myanmar_owin]\nacledmyanmar_2021.Q2_ppp = acled_2021.Q2_ppp[myanmar_owin]\nacledmyanmar_2021.Q3_ppp = acled_2021.Q3_ppp[myanmar_owin]\nacledmyanmar_2021.Q4_ppp = acled_2021.Q4_ppp[myanmar_owin]\n\nacledmyanmar_2022.Q1_ppp = acled_2022.Q1_ppp[myanmar_owin]\nacledmyanmar_2022.Q2_ppp = acled_2022.Q2_ppp[myanmar_owin]\nacledmyanmar_2022.Q3_ppp = acled_2022.Q3_ppp[myanmar_owin]\nacledmyanmar_2022.Q4_ppp = acled_2022.Q4_ppp[myanmar_owin]\n\nacledmyanmar_2023.Q1_ppp = acled_2023.Q1_ppp[myanmar_owin]\nacledmyanmar_2023.Q2_ppp = acled_2023.Q2_ppp[myanmar_owin]\nacledmyanmar_2023.Q3_ppp = acled_2023.Q3_ppp[myanmar_owin]\nacledmyanmar_2023.Q4_ppp = acled_2023.Q4_ppp[myanmar_owin]\n\nacledmyanmar_2024.Q1_ppp = acled_2024.Q1_ppp[myanmar_owin]\nacledmyanmar_2024.Q2_ppp = acled_2024.Q2_ppp[myanmar_owin]\n```\n:::\n\n\nThe output object combines both the point and polygon feature in one `ppp` object class as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(acledmyanmar_2021.Q1_ppp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(acledmyanmar_2021.Q1_ppp)\n```\n:::\n\n\n# 5.0 First-order Spatial Point Patterns Analysis\n\nAfter data wrangling is complete, we will perform first-order spatial point pattern analysis using functions from the `spatstat` package.\n\n## 5.1 Kernel Density Estimation\n\n### 5.1.1 Rescaling KDE Layers\n\nWe will use `rescale()` function of **spatstat** package to covert the unit of measurement from meter to kilometer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacledmyanmar_ppp.km <- rescale(acledmyanmar_ppp, 1000, \"km\")\n\n# by quarters\nacledmyanmar_2021.Q1_ppp.km <- rescale(acledmyanmar_2021.Q1_ppp, 1000, \"km\")\nacledmyanmar_2021.Q2_ppp.km <- rescale(acledmyanmar_2021.Q2_ppp, 1000, \"km\")\nacledmyanmar_2021.Q3_ppp.km <- rescale(acledmyanmar_2021.Q3_ppp, 1000, \"km\")\nacledmyanmar_2021.Q4_ppp.km <- rescale(acledmyanmar_2021.Q4_ppp, 1000, \"km\")\n\nacledmyanmar_2022.Q1_ppp.km <- rescale(acledmyanmar_2022.Q1_ppp, 1000, \"km\")\nacledmyanmar_2022.Q2_ppp.km <- rescale(acledmyanmar_2022.Q2_ppp, 1000, \"km\")\nacledmyanmar_2022.Q3_ppp.km <- rescale(acledmyanmar_2022.Q3_ppp, 1000, \"km\")\nacledmyanmar_2022.Q4_ppp.km <- rescale(acledmyanmar_2022.Q4_ppp, 1000, \"km\")\n\nacledmyanmar_2023.Q1_ppp.km <- rescale(acledmyanmar_2023.Q1_ppp, 1000, \"km\")\nacledmyanmar_2023.Q2_ppp.km <- rescale(acledmyanmar_2023.Q2_ppp, 1000, \"km\")\nacledmyanmar_2023.Q3_ppp.km <- rescale(acledmyanmar_2023.Q3_ppp, 1000, \"km\")\nacledmyanmar_2023.Q4_ppp.km <- rescale(acledmyanmar_2023.Q4_ppp, 1000, \"km\")\n\nacledmyanmar_2024.Q1_ppp.km <- rescale(acledmyanmar_2024.Q1_ppp, 1000, \"km\")\nacledmyanmar_2024.Q2_ppp.km <- rescale(acledmyanmar_2024.Q2_ppp, 1000, \"km\")\n```\n:::\n\n\n## 5.2 Quarterly KDE layers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkde_acledmyanmar_2021.Q1.bw <- density(acledmyanmar_2021.Q1_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2021.Q2.bw <- density(acledmyanmar_2021.Q2_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2021.Q3.bw <- density(acledmyanmar_2021.Q3_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2021.Q4.bw <- density(acledmyanmar_2021.Q4_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\n\nkde_acledmyanmar_2022.Q1.bw <- density(acledmyanmar_2022.Q1_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2022.Q2.bw <- density(acledmyanmar_2022.Q2_ppp.km, \n                                      sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2022.Q3.bw <- density(acledmyanmar_2022.Q3_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2022.Q4.bw <- density(acledmyanmar_2022.Q4_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\n\nkde_acledmyanmar_2023.Q1.bw <- density(acledmyanmar_2023.Q1_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2023.Q2.bw <- density(acledmyanmar_2023.Q2_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2023.Q3.bw <- density(acledmyanmar_2023.Q3_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2023.Q4.bw <- density(acledmyanmar_2023.Q4_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\n\nkde_acledmyanmar_2024.Q1.bw <- density(acledmyanmar_2024.Q1_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2024.Q2.bw <- density(acledmyanmar_2024.Q2_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,4)) \n\nplot(kde_acledmyanmar_2021.Q1.bw)\nplot(kde_acledmyanmar_2021.Q2.bw)\nplot(kde_acledmyanmar_2021.Q3.bw)\nplot(kde_acledmyanmar_2021.Q4.bw)\n\nplot(kde_acledmyanmar_2022.Q1.bw)\nplot(kde_acledmyanmar_2022.Q2.bw)\nplot(kde_acledmyanmar_2022.Q3.bw)\nplot(kde_acledmyanmar_2022.Q4.bw)\n\nplot(kde_acledmyanmar_2023.Q1.bw)\nplot(kde_acledmyanmar_2023.Q2.bw)\nplot(kde_acledmyanmar_2023.Q3.bw)\nplot(kde_acledmyanmar_2023.Q4.bw)\n\nplot(kde_acledmyanmar_2024.Q1.bw)\nplot(kde_acledmyanmar_2024.Q2.bw)\n```\n:::\n\n\n# 6.0 Second-order Spatial Point Patterns Analysis\n\n## 6.1 Data Wrangling for Second-order analysis\n\n#### 6.1.1 Extracting study areas\n\nThe code chunk below targets the areas with the highest amount of activity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_sf\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSGI <- myanmar_sf %>%\n  filter(ST == \"Sagaing\")\nKC <- myanmar_sf %>%\n  filter(ST == \"Kachin\")\nMW <- myanmar_sf %>%\n  filter(ST == \"Magway\")\nMDL <- myanmar_sf %>%\n  filter(ST == \"Mandalay\")\n```\n:::\n\n\n#### 6.1.2 Converting sf objects into ***owin*** objects\n\nNow, we will convert these sf objects into owin objects that is required by **spatstat**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSGI_owin <- as.owin(SGI)\nKC_owin <- as.owin(KC)\nMW_owin <- as.owin(MW)\nMDL_owin <- as.owin(MDL)\n```\n:::\n\n\n#### 6.1.3 Combining event points and the study area\n\nBy using the code chunk below, we are able to extract events that is within specific regions to do our analysis later on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSGI_ppp = acled_ppp_jit[SGI_owin]\nKC_ppp = acled_ppp_jit[KC_owin]\nMW_ppp = acled_ppp_jit[MW_owin]\nMDL_ppp = acled_ppp_jit[MDL_owin]\n```\n:::\n\n\n`rescale()` is used to transform the unit of measurement from meters to kilometers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSGI_ppp.km = rescale(SGI_ppp, 1000, \"km\")\nKC_ppp.km = rescale(KC_ppp, 1000, \"km\")\nMW_ppp.km = rescale(MW_ppp, 1000, \"km\")\nMDL_ppp.km = rescale(MDL_ppp, 1000, \"km\")\n```\n:::\n\n\nThe code chunk below plots the four study areas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\nplot(SGI_ppp.km, main=\"Sagaing\")\nplot(KC_ppp.km, main=\"Kachin\")\nplot(MW_ppp.km, main=\"Magway\")\nplot(MDL_ppp.km, main=\"Mandalay\")\n```\n:::\n\n\n## 6.2 Analysing Spatial Point Process Using G-Function\n\n#### 6.2.1 Sagaing area\n\nThe code chunk below is used to compute G-function using *Gest()* of **spatat** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_SGI = Gest(SGI_ppp, correction = \"border\")\nplot(G_SGI, xlim=c(0,500))\n```\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\n-   Ho = The distribution of events in Sagaing are randomly distributed.\n\n-   H1= The distribution of events in Sagaing are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_SGI.csr <- envelope(SGI_ppp, Gest, nsim = 249)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(G_SGI.csr)\n```\n:::\n\n\n#### 6.2.2 Kachin area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_KC = Gest(KC_ppp, correction = \"border\")\nplot(G_KC, xlim=c(0,500))\n```\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\n-   Ho = The distribution of events in Kachin are randomly distributed.\n\n-   H1= The distribution of events in Kachin are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_KC.csr <- envelope(KC_ppp, Gest, nsim = 249)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(G_KC.csr)\n```\n:::\n\n\n#### 6.2.3 Magway area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MW = Gest(MW_ppp, correction = \"border\")\nplot(G_MW, xlim=c(0,500))\n```\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\n-   Ho = The distribution of events in Magway are randomly distributed.\n\n-   H1= The distribution of events in Magway are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MW.csr <- envelope(MW_ppp, Gest, nsim = 249)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(G_MW.csr)\n```\n:::\n\n\n#### 6.2.4 Mandalay area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MDL = Gest(MDL_ppp, correction = \"border\")\nplot(G_MDL, xlim=c(0,500))\n```\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\n-   Ho = The distribution of events in Mandalay are randomly distributed.\n\n-   H1= The distribution of events in Mandalay are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MDL.csr <- envelope(MDL_ppp, Gest, nsim = 249)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(G_MDL.csr)\n```\n:::\n\n\n# 7.0 Computing Spatio-temporal KDE\n\nThe code chunk below is used to convert data type of *event_date* to numeric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf_2021_mutated <- acled_sf %>% \n  filter(year == 2021) %>%\n  mutate(Quarter_label = quarter(event_date))\n\nacled_sf_2022_mutated <- acled_sf %>% \n  filter(year == 2022) %>%\n  mutate(Quarter_label = quarter(event_date))\n\nacled_sf_2023_mutated <- acled_sf %>% \n  filter(year == 2023) %>%\n  mutate(Quarter_label = quarter(event_date))\n\nacled_sf_2024_mutated <- acled_sf %>% \n  filter(year == 2024) %>%\n  mutate(Quarter_label = quarter(event_date))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_quarter_2021 <- acled_sf_2021_mutated %>% \n  dplyr::select(Quarter_label)\n\nacled_quarter_2022 <- acled_sf_2022_mutated %>% \n  dplyr::select(Quarter_label)\n\nacled_quarter_2023 <- acled_sf_2023_mutated %>% \n  dplyr::select(Quarter_label)\n\nacled_quarter_2024 <- acled_sf_2024_mutated %>% \n  dplyr::select(Quarter_label)\n```\n:::\n\n\n### 7.1.1 Creating ppp object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_quarter_2021_ppp <- as.ppp(acled_quarter_2021)\nacled_quarter_2022_ppp <- as.ppp(acled_quarter_2022)\nacled_quarter_2023_ppp <- as.ppp(acled_quarter_2023)\nacled_quarter_2024_ppp <- as.ppp(acled_quarter_2024)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(acled_quarter_2021_ppp)\nsummary(acled_quarter_2022_ppp)\nsummary(acled_quarter_2023_ppp)\nsummary(acled_quarter_2024_ppp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_quarter_2021_ppp <- rjitter(acled_quarter_2021_ppp, \n                                 retry=TRUE, \n                                 nsim=1, \n                                 drop=TRUE)\nacled_quarter_2022_ppp <- rjitter(acled_quarter_2022_ppp, \n                                 retry=TRUE, \n                                 nsim=1, \n                                 drop=TRUE)\nacled_quarter_2023_ppp <- rjitter(acled_quarter_2023_ppp, \n                                 retry=TRUE, \n                                 nsim=1, \n                                 drop=TRUE)\nacled_quarter_2024_ppp <- rjitter(acled_quarter_2024_ppp, \n                                 retry=TRUE, \n                                 nsim=1, \n                                 drop=TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(acled_quarter_2021_ppp))\n```\n:::\n\n\n### 7.1.2 Including owin object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_quarter_2021_owin <- acled_quarter_2021_ppp[myanmar_owin]\nacled_quarter_2022_owin <- acled_quarter_2022_ppp[myanmar_owin]\nacled_quarter_2023_owin <- acled_quarter_2023_ppp[myanmar_owin]\nacled_quarter_2024_owin <- acled_quarter_2024_ppp[myanmar_owin]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(acled_quarter_2021_owin)\n```\n:::\n\n\n## 7.2 Computing spatio-temporal KDE by quarters\n\n`spattemp.density()` of sparr package is used to compute the STKDE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacledmyanmar_2021_kde <- spattemp.density(acled_quarter_2021_owin)\nacledmyanmar_2022_kde <- spattemp.density(acled_quarter_2022_owin)\nacledmyanmar_2023_kde <- spattemp.density(acled_quarter_2023_owin)\nacledmyanmar_2024_kde <- spattemp.density(acled_quarter_2024_owin)\n```\n:::\n\n\n### 7.2.1 Plotting the spatio-temporal KDE object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquarters <- c(1,2,3,4)\npar(mfcol=c(1,4))\nfor(i in quarters){ \n  plot(acledmyanmar_2021_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at 2021 Q\",i))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfcol=c(1,4))\nfor(i in quarters){ \n  plot(acledmyanmar_2022_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at 2022 Q\",i))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfcol=c(1,4))\nfor(i in quarters){ \n  plot(acledmyanmar_2023_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at 2023 Q\",i))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nquarters <- c(1,2)\npar(mfcol=c(1,2))\nfor(i in quarters){ \n  plot(acledmyanmar_2024_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at 2024 Q\",i))\n}\n```\n:::\n\n\n# 8.0 2nd-Order Spatio-Temporal Point Patterns Analysis\n\nUnfortunately, I was unable to understand the requirements of this task as I could not locate a tutorial to render this, and Google was unhelpful in explaining. I have asked other schoolmates for assistance to try and obtain a result, but as it was unsuccessful, I have chosen not to include it in my site.\n\n# 9.0 Displaying layers on openstreetmap\n\n## 9.1 Displaying KDE layers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nosm <- osm %>% \n  dplyr::select('osm_id', 'fclass')\nosm <- st_transform(osm, crs = 32647)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmerged_myanmar <- st_union(myanmar_sf)\nosm_myanmar <- st_intersection(osm, merged_myanmar)\n\n# splitting MULTILINESTRING into individual LINESTRING as it may cause issues with KDE calculations\nosm_myanmar <- st_cast(st_cast(osm_myanmar, \"MULTILINESTRING\"),\"LINESTRING\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(osm_myanmar, \"data/rds/osm_myanmar.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_density <- density(acledmyanmar_ppp, \n             sigma=25, \n             edge=TRUE, \n             kernel=\"gaussian\")\n\ndensity_raster <- raster(test_density)\nprojection(density_raster) <- CRS(\"+init=EPSG:32647\")\n\nplot(osm_myanmar)\n```\n:::\n\n\n## 9.2 Displaying STKDE layers\n\nAs the calculation will be large, I have created a function to lessen code duplication.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_stkde <- function(kde) {\n  test_density <- density(kde, \n               sigma=25, \n               edge=TRUE, \n               kernel=\"gaussian\")\n  \n  density_raster <- raster(test_density)\n  projection(density_raster) <- CRS(\"+init=EPSG:32647\")\n  \n  plot(osm_myanmar)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_stkde(acled_quarter_2021_ppp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_stkde(acled_quarter_2022_ppp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_stkde(acled_quarter_2023_ppp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_stkde(acled_quarter_2024_ppp)\n```\n:::\n\n\n# 10.0 Describing spatial patterns revealed by KDE and Spatio-temporal KDE maps\n\nThe maps represent the intensity of armed conflict across Myanmar from 2021 to 2024. (5.2)\n\nThere is a consistent hotspot area in the northwestern part of Myanmar. Meanwhile, the central parts of the country show varying levels of intensity across the years and the southern region experiences a lot fewer conflicts.\n\nSTKDE is more advantageous than KDE as it utilizes time in its method.\n\nUnfortunately, though I managed to import openstreetmaps, I was regrettably unable to implement it in the code as my laptop struggled with rendering it and thus had to figure out another method to display the layers.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}